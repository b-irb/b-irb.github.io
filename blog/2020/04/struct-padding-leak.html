<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Information Leakage With Struct Padding</title>
</head>
<style>
footer {
    font-size: 13px;
}

body {
    font: 1em "Arial", sans-serif;
    overflow-wrap: normal;
    max-width: 80%;
    margin: 0 auto 0 auto;
}

img {
    max-width: 100%;
}

pre {
    font: 0.9em "Courier New";
}

nav ul {
    list-style: none;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    padding: 0px;
}

nav ul li {
    margin-right: 20px;
}

code {
    font-size: 1.4em;
}

blockquote {
    margin-left: 5px;
    padding-left: 15px;
    border-left: 3px solid #ccc;
}

@media screen and (min-width: 800px) {
body {
    max-width: 50%;
}
}

</style>
<body>
<nav>
    <ul>
        <li><a href="/">Index</a></li>
        <!-- GitHub Pages complains about missing .html -->
        <li><a href="/blog.html">blog</a></li>
    </ul>
</nav>
<h1>Information Leakage With Struct Padding</h1>
<article><p>Information leakage is a common auxiliary to execute an elaborate exploit. Process memory may contain secrets, such as: passwords, encryption keys, stack canaries, pointers to other data structures, etc. Consequently, allowing an attacker to leak process memory can have significant consequences. Typically, information leakage is the result of forcing an application to output uninitialised memory (considered UB in most, sane, languages).</p>
<p>An example of information leakage is as follows:</p>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">#include </span><span style="color:#183691;">&lt;stdio.h&gt;
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> buf[</span><span style="color:#0086b3;">16</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">{</span><span style="color:#183691;">&#39;J&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;U&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;N&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;K&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;J&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;U&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;N&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;K&#39;</span><span style="color:#323232;">,
</span><span style="color:#323232;">                    </span><span style="color:#183691;">&#39;J&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;U&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;N&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;K&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;J&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;U&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;N&#39;</span><span style="color:#323232;">, </span><span style="color:#183691;">&#39;K&#39;</span><span style="color:#323232;">};
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> miscellaneous_stack_data[</span><span style="color:#0086b3;">100</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;hunter2&quot;</span><span style="color:#323232;">;
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">fgets</span><span style="color:#323232;">(buf, </span><span style="font-weight:bold;color:#a71d5d;">sizeof</span><span style="color:#323232;">(buf), stdin);
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">printf</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">%s\n</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, buf);
</span><span style="color:#323232;">}
</span></pre>
</code></pre>
<p>We allocate a buffer, <code>buf</code>, containing “junk bytes” (suppose these were leftover local variables from previous functions). Then we create a <code>miscellaneous_stack_data</code> buffer that contains a secret`. We attempt to place both buffers adjacently in memory.</p>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">(gdb) p &amp;buf
</span><span style="color:#323232;">$1 = (char (*)[16]) 0x7fffffffdf30
</span><span style="color:#323232;">(gdb) p &amp;miscellaneous_stack_data
</span><span style="color:#323232;">$2 = (char (*)[100]) 0x7fffffffdf40
</span></pre>
</code></pre>
<p>Next, we attempt to read 16 bytes into <code>buf</code> with <code>fgets</code> then output the buffer to stdout. This looks fine but if we check the manpage for <code>fgets</code> we see:</p>
<blockquote>
<p>fgets() reads in at most one less than size characters from stream and stores
them into the buffer pointed to by s. Reading stops after an EOF or a newline.
If a newline is read, it is stored into the buffer. A terminating null byte
(‘\0’) is stored after the last character in the buffer.</p>
</blockquote>
<p>If we skim this description it looks fine, <code>fgets</code> will place a null terminator once it encounters a newline or if it reads <code>size</code> characters. However, if we read more carefully <em>Reading stops after an EOF</em>. By sending an EOF (ctrl+d on most Linux terminals), we realise <code>fgets</code> will not place a null terminator which allows us to leak the password.</p>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">[user@beelzebub]: /tmp/tmp.zoum9Gc3En&gt;$ gcc vuln.c -Wall -Wextra -pedantic -o vuln
</span><span style="color:#323232;">vuln.c: In function ‘main’:
</span><span style="color:#323232;">vuln.c:6:10: warning: unused variable ‘miscellaneous_stack_data’ [-Wunused-variable]
</span><span style="color:#323232;">    6 |     char miscellaneous_stack_data[100] = &quot;hunter2&quot;;
</span><span style="color:#323232;">      |          ^~~~~~~~~~~~~~~~~~~~~~~~
</span><span style="color:#323232;">[user@beelzebub]: /tmp/tmp.zoum9Gc3En&gt;$ ./vuln
</span><span style="color:#323232;">JUNKJUNKJUNKJUNKhunter2
</span></pre>
</code></pre>
<p>We recieve no warnings or errors for our misuse of <code>fgets</code> but why would we? This behaviour is documented but commonly overlooked. From this example you ought to see how easy it is to accidentally leak process memory even with frequently used functions (to mitigate the above you should <code>memset</code> your buffer beforehand and ensure a null terminator is present).</p>
<p>Now, onto structs! A struct is a way in which we combine multiple heterogeneous datatypes into a single, coherent, structure. An example is shown below.</p>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">_sigma16_cpu {
</span><span style="color:#323232;">    sigma16_reg_t regs[</span><span style="color:#0086b3;">16</span><span style="color:#323232;">];
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">union</span><span style="color:#323232;"> sigma16_inst_variant ir;
</span><span style="color:#323232;">    sigma16_reg_t pc;
</span><span style="color:#323232;">    sigma16_reg_t adr;
</span><span style="color:#323232;">    sigma16_reg_t dat;
</span><span style="color:#323232;">    sigma16_reg_status_t status;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">_Bool</span><span style="color:#323232;"> sys;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">_Bool</span><span style="color:#323232;"> ie;
</span><span style="color:#323232;">    sigma16_reg_t mask;
</span><span style="color:#323232;">    sigma16_reg_t req;
</span><span style="color:#323232;">    sigma16_reg_status_t istat;
</span><span style="color:#323232;">    sigma16_reg_t ipc;
</span><span style="color:#323232;">    sigma16_reg_t vect;
</span><span style="color:#323232;">}
</span></pre>
</code></pre>
<p>The struct, <code>_sigma16_cpu</code> has several fields (e.g. <code>pc</code>, <code>adr</code>, <code>status</code>) which can be individually accessed. To improve performance, the C compiler will attempt to align the size of the struct to the size of the largest field. However, not all the datatypes have the same size (<code>assert(sizeof(char) == sizeof(int))</code> will fail) so to properly align the struct the compiler will insert padding bytes.</p>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">#include </span><span style="color:#183691;">&lt;assert.h&gt;
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> C {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> x; </span><span style="font-style:italic;color:#969896;">/* 1 */
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> y;  </span><span style="font-style:italic;color:#969896;">/* 4 */
</span><span style="color:#323232;">};
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> I {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> x;  </span><span style="font-style:italic;color:#969896;">/* 4 */
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> y;  </span><span style="font-style:italic;color:#969896;">/* 4 */
</span><span style="color:#323232;">};
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> C c </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">{.x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&#39;A&#39;</span><span style="color:#323232;">, .y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">41</span><span style="color:#323232;">};
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> I i </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">{.x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">41</span><span style="color:#323232;">, .y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">41</span><span style="color:#323232;">};
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">assert</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">sizeof</span><span style="color:#323232;">(c) </span><span style="font-weight:bold;color:#a71d5d;">== sizeof</span><span style="color:#323232;">(i));
</span><span style="color:#323232;">}
</span></pre>
</code></pre>
<p>In both structs, <code>int</code> is the largest data type which means both structs will attempt to align to it. However, <code>char</code> has a size of 1 so the compiler inserts 3 padding bytes, bringing the size of <code>struct C</code> to 8.</p>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">[user@beelzebub]: /tmp/tmp.s3NX4aNGmq&gt;$ gcc test.c -o test
</span><span style="color:#323232;">[user@beelzebub]: /tmp/tmp.s3NX4aNGmq&gt;$ ./test
</span><span style="color:#323232;">[user@beelzebub]: /tmp/tmp.s3NX4aNGmq&gt;$
</span></pre>
</code></pre>
<p>As we can see, the assertion held. In other languages the fields of a struct may be reorganised to improve structure size by reducing the amount of padding bytes required.</p>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> A {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> x;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> y;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> z;
</span><span style="color:#323232;">}; </span><span style="font-style:italic;color:#969896;">/* sizeof(struct A) == 12 */
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> B {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> x;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> z;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> y;
</span><span style="color:#323232;">}; </span><span style="font-style:italic;color:#969896;">/* sizeof(struct B) == 8 */
</span></pre>
</code></pre>
<p>Despite having the same fields, <code>struct A</code> is larger than <code>struct B</code>. Although, if you want to remove padding entirely you can use <code>__attribute__((packed))</code>.</p>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">__attribute__</span><span style="color:#323232;">((packed)) </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> A {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> x;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> y;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> z;
</span><span style="color:#323232;">}; </span><span style="font-style:italic;color:#969896;">/* sizeof(struct A) == 6 */
</span></pre>
</code></pre>
<p>However, this is not a compiler directive and removing padding will make structures cache-unfriendly which will likely hamper performance.</p>
<p>How do padding bytes replate to information leakage? Padding bytes pare not <em>safely accessible in C and may contain arbitrary memory</em>. Places where this may occur is where we write a struct by doing <code>foo(&amp;my_struct, sizeof(my_struct));</code> because you are including padding bytes. Instead, to write and read in structs, you should do it by individually accessing each field. An example application with an information leakage from struct padding is below.</p>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">#include </span><span style="color:#183691;">&lt;crypt.h&gt;
</span><span style="font-weight:bold;color:#a71d5d;">#include </span><span style="color:#183691;">&lt;stdio.h&gt;
</span><span style="font-weight:bold;color:#a71d5d;">#include </span><span style="color:#183691;">&lt;string.h&gt;
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">#define </span><span style="color:#323232;">KEY_SIZE </span><span style="color:#0086b3;">16
</span><span style="font-weight:bold;color:#a71d5d;">#define </span><span style="color:#323232;">SALT_SIZE </span><span style="color:#0086b3;">16
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">#define </span><span style="color:#323232;">BLOWFISH </span><span style="color:#0086b3;">2
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">credentials {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> salt[SALT_SIZE];
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;"> key[KEY_SIZE];
</span><span style="color:#323232;">};
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">encrypted {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">unsigned char</span><span style="color:#323232;"> scheme;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">long long</span><span style="color:#323232;"> uid;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">unsigned char</span><span style="color:#323232;"> version;
</span><span style="color:#323232;">};
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">char* </span><span style="font-weight:bold;color:#795da3;">read_user_creds</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> credentials</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">creds) {
</span><span style="color:#323232;">    </span><span style="font-style:italic;color:#969896;">/* clear memory for null bytes */
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">memset</span><span style="color:#323232;">(creds-&gt;key, </span><span style="color:#183691;">&#39;</span><span style="color:#0086b3;">\0</span><span style="color:#183691;">&#39;</span><span style="color:#323232;">, KEY_SIZE);
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">memset</span><span style="color:#323232;">(creds-&gt;salt, </span><span style="color:#183691;">&#39;</span><span style="color:#0086b3;">\0</span><span style="color:#183691;">&#39;</span><span style="color:#323232;">, SALT_SIZE);
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">fgets</span><span style="color:#323232;">(creds-&gt;key, KEY_SIZE, stdin);
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">fgets</span><span style="color:#323232;">(creds-&gt;salt, SALT_SIZE, stdin);
</span><span style="color:#323232;">}
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">char* </span><span style="font-weight:bold;color:#795da3;">encrypt_user_data</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">void</span><span style="color:#323232;">) {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> credentials creds;
</span><span style="color:#323232;">    read_user_creds(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">creds);
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#323232;">crypt(creds.key, creds.salt);
</span><span style="color:#323232;">}
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="font-weight:bold;color:#795da3;">save_ciphertext_info</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">const char* </span><span style="color:#323232;">fname) {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">static int</span><span style="color:#323232;"> uid </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> encrypted blob </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">{.scheme </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> BLOWFISH, uid </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> uid</span><span style="font-weight:bold;color:#a71d5d;">++</span><span style="color:#323232;">, .version </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">};
</span><span style="color:#323232;">    FILE</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> save_file;
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">(save_file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">fopen</span><span style="color:#323232;">(fname, </span><span style="color:#183691;">&quot;wb&quot;</span><span style="color:#323232;">))) {
</span><span style="color:#323232;">        </span><span style="font-weight:bold;color:#a71d5d;">return -</span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">fwrite</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">blob, </span><span style="font-weight:bold;color:#a71d5d;">sizeof</span><span style="color:#323232;">(blob), </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, save_file);
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">fclose</span><span style="color:#323232;">(save_file);
</span><span style="color:#323232;">}
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">char*</span><span style="color:#323232;"> encrypted;
</span><span style="color:#323232;">    encrypted </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">encrypt_user_data();
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">(save_ciphertext_info(</span><span style="color:#183691;">&quot;ciphertext_info.bin&quot;</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">0</span><span style="color:#323232;">) {
</span><span style="color:#323232;">        </span><span style="font-weight:bold;color:#a71d5d;">return -</span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">printf</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;encrypted: </span><span style="color:#0086b3;">%s\n</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, encrypted);
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span><span style="color:#323232;">}
</span></pre>
</code></pre>
<p>The application asks a user for their password and a salt to encrypt using <code>crypt</code>. Then the application emits the an encyption id, application version, and the encryption scheme.</p>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">[user@beelzebub]: /tmp/tmp.eFj7oJofHA&gt;$ gcc vuln.c -lcrypt -Wall -Wextra -pedantic -o vuln
</span><span style="color:#323232;">[user@beelzebub]: /tmp/tmp.eFj7oJofHA&gt;$ ./vuln
</span><span style="color:#323232;">hunter2
</span><span style="color:#323232;">s4lt
</span><span style="color:#323232;">encrypted: s4Rw0kbw0ZFaU
</span><span style="color:#323232;">[user@beelzebub]: /tmp/tmp.eFj7oJofHA&gt;$ stat ciphertext_info.bin
</span><span style="color:#323232;">  File: ciphertext_info.bin
</span><span style="color:#323232;">  Size: 24        	Blocks: 8          IO Block: 4096   regular file
</span><span style="color:#323232;">Device: 2dh/45d	Inode: 679587      Links: 1
</span><span style="color:#323232;">Access: (0644/-rw-r--r--)  Uid: ( 1000/    user)   Gid: ( 1000/    user)
</span><span style="color:#323232;">Access: 2020-04-19 22:46:08.728239131 +0100
</span><span style="color:#323232;">Modify: 2020-04-19 22:46:27.114905573 +0100
</span><span style="color:#323232;">Change: 2020-04-19 22:46:27.114905573 +0100
</span><span style="color:#323232;"> Birth: -
</span><span style="color:#323232;">[user@beelzebub]: /tmp/tmp.eFj7oJofHA&gt;$ xxd ciphertext_info.bin
</span><span style="color:#323232;">00000000: 0275 6e74 6572 320a 0000 0000 0000 0000  .unter2.........
</span><span style="color:#323232;">00000010: 0000 0000 0000 0000                      ........
</span></pre>
</code></pre>
<p>A chunk of the password is right there even though we wrote an unrelated piece of information to the file.</p>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">int </span><span style="font-weight:bold;color:#795da3;">save_ciphertext_info</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">const char* </span><span style="color:#323232;">fname) {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">static int</span><span style="color:#323232;"> uid </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> encrypted blob </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">{.scheme </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> BLOWFISH, uid </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> uid</span><span style="font-weight:bold;color:#a71d5d;">++</span><span style="color:#323232;">, .version </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">};
</span><span style="color:#323232;">    FILE</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> save_file;
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">(save_file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">fopen</span><span style="color:#323232;">(fname, </span><span style="color:#183691;">&quot;wb&quot;</span><span style="color:#323232;">))) {
</span><span style="color:#323232;">        </span><span style="font-weight:bold;color:#a71d5d;">return -</span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">fwrite</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">blob, </span><span style="font-weight:bold;color:#a71d5d;">sizeof</span><span style="color:#323232;">(blob), </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, save_file);
</span><span style="color:#323232;">    </span><span style="color:#62a35c;">fclose</span><span style="color:#323232;">(save_file);
</span><span style="color:#323232;">}
</span></pre>
</code></pre>
<p>Why does this work? Within the application, we allocate a struct on the stack which stores sensitive information. Then, we allocate another struct on the stack within a different function body. The struct padding of our second struct overlaps the <code>key</code> field of the <code>credentials</code> struct. When we write the entire struct to a file we also write this padding field, which includes part of our password. However, first byte is overwritten by the scheme.</p>
<p>We can inspect this overlapping by debugging the application.</p>
<pre style="background-color:#ffffff;">
<span style="color:#323232;">[user@beelzebub]: /tmp/tmp.eFj7oJofHA&gt;$ gdb -q vuln
</span><span style="color:#323232;">Reading symbols from vuln...
</span><span style="color:#323232;">(gdb) disass encrypt_user_data
</span><span style="color:#323232;">Dump of assembler code for function encrypt_user_data:
</span><span style="color:#323232;">   0x000000000000121f &lt;+0&gt;:	push   rbp
</span><span style="color:#323232;">   0x0000000000001220 &lt;+1&gt;:	mov    rbp,rsp
</span><span style="color:#323232;">   0x0000000000001223 &lt;+4&gt;:	sub    rsp,0x30
</span><span style="color:#323232;">   0x0000000000001227 &lt;+8&gt;:	mov    rax,QWORD PTR fs:0x28
</span><span style="color:#323232;">   0x0000000000001230 &lt;+17&gt;:	mov    QWORD PTR [rbp-0x8],rax
</span><span style="color:#323232;">   0x0000000000001234 &lt;+21&gt;:	xor    eax,eax
</span><span style="color:#323232;">   0x0000000000001236 &lt;+23&gt;:	lea    rax,[rbp-0x30]
</span><span style="color:#323232;">   0x000000000000123a &lt;+27&gt;:	mov    rdi,rax
</span><span style="color:#323232;">   0x000000000000123d &lt;+30&gt;:	call   0x11a9 &lt;read_user_creds&gt;
</span><span style="color:#323232;">   0x0000000000001242 &lt;+35&gt;:	lea    rax,[rbp-0x30]
</span><span style="color:#323232;">   0x0000000000001246 &lt;+39&gt;:	lea    rdx,[rbp-0x30]
</span><span style="color:#323232;">   0x000000000000124a &lt;+43&gt;:	add    rdx,0x10
</span><span style="color:#323232;">   0x000000000000124e &lt;+47&gt;:	mov    rsi,rax
</span><span style="color:#323232;">   0x0000000000001251 &lt;+50&gt;:	mov    rdi,rdx
</span><span style="color:#323232;">   0x0000000000001254 &lt;+53&gt;:	call   0x1070 &lt;crypt@plt&gt;
</span><span style="color:#323232;">   0x0000000000001259 &lt;+58&gt;:	mov    rcx,QWORD PTR [rbp-0x8]
</span><span style="color:#323232;">   0x000000000000125d &lt;+62&gt;:	xor    rcx,QWORD PTR fs:0x28
</span><span style="color:#323232;">   0x0000000000001266 &lt;+71&gt;:	je     0x126d &lt;encrypt_user_data+78&gt;
</span><span style="color:#323232;">   0x0000000000001268 &lt;+73&gt;:	call   0x1040 &lt;__stack_chk_fail@plt&gt;
</span><span style="color:#323232;">   0x000000000000126d &lt;+78&gt;:	leave
</span><span style="color:#323232;">   0x000000000000126e &lt;+79&gt;:	ret
</span><span style="color:#323232;">End of assembler dump.
</span><span style="color:#323232;">(gdb) b *encrypt_user_data+27
</span><span style="color:#323232;">Breakpoint 1 at 0x123a: file vuln.c, line 32.
</span><span style="color:#323232;">(gdb) r
</span><span style="color:#323232;">Starting program: /tmp/tmp.eFj7oJofHA/vuln
</span><span style="color:#323232;">
</span><span style="color:#323232;">Breakpoint 1, 0x000055555555523a in encrypt_user_data () at vuln.c:32
</span><span style="color:#323232;">32	    read_user_creds(&amp;creds);
</span><span style="color:#323232;">(gdb) p &amp;creds-&gt;key
</span><span style="color:#323232;">$1 = (char (*)[16]) 0x7fffffffe0d0
</span><span style="color:#323232;">(gdb) disass save_ciphertext_info
</span><span style="color:#323232;">Dump of assembler code for function save_ciphertext_info:
</span><span style="color:#323232;">   0x000055555555526f &lt;+0&gt;:	push   rbp
</span><span style="color:#323232;">   0x0000555555555270 &lt;+1&gt;:	mov    rbp,rsp
</span><span style="color:#323232;">   0x0000555555555273 &lt;+4&gt;:	sub    rsp,0x40
</span><span style="color:#323232;">   0x0000555555555277 &lt;+8&gt;:	mov    QWORD PTR [rbp-0x38],rdi
</span><span style="color:#323232;">   0x000055555555527b &lt;+12&gt;:	mov    rax,QWORD PTR fs:0x28
</span><span style="color:#323232;">   0x0000555555555284 &lt;+21&gt;:	mov    QWORD PTR [rbp-0x8],rax
</span><span style="color:#323232;">   0x0000555555555288 &lt;+25&gt;:	xor    eax,eax
</span><span style="color:#323232;">   0x000055555555528a &lt;+27&gt;:	mov    BYTE PTR [rbp-0x20],0x2
</span><span style="color:#323232;">   0x000055555555528e &lt;+31&gt;:	mo    eax,DWORD PTR [rip+0x2de8]        # 0x55555555807c &lt;uid.2508&gt;
</span><span style="color:#323232;">   0x0000555555555294 &lt;+37&gt;:	lea    edx,[rax+0x1]
</span><span style="color:#323232;">   0x0000555555555297 &lt;+40&gt;:	mov    DWORD PTR [rip+0x2ddf],edx        # 0x55555555807c &lt;uid.2508&gt;
</span><span style="color:#323232;">   0x000055555555529d &lt;+46&gt;:	cdqe
</span><span style="color:#323232;">   0x000055555555529f &lt;+48&gt;:	mov    QWORD PTR [rbp-0x18],rax
</span><span style="color:#323232;">   0x00005555555552a3 &lt;+52&gt;:	mov    BYTE PTR [rbp-0x10],0x0
</span><span style="color:#323232;">   0x00005555555552a7 &lt;+56&gt;:	mov    rax,QWORD PTR [rbp-0x38]
</span><span style="color:#323232;">   0x00005555555552ab &lt;+60&gt;:	lea    rsi,[rip+0xd52]        # 0x555555556004
</span><span style="color:#323232;">   0x00005555555552b2 &lt;+67&gt;:	mov    rdi,rax
</span><span style="color:#323232;">   0x00005555555552b5 &lt;+70&gt;:	call   0x555555555090 &lt;fopen@plt&gt;
</span><span style="color:#323232;">   0x00005555555552ba &lt;+75&gt;:	mov    QWORD PTR [rbp-0x28],rax
</span><span style="color:#323232;">   0x00005555555552be &lt;+79&gt;:	cmp    QWORD PTR [rbp-0x28],0x0
</span><span style="color:#323232;">   0x00005555555552c3 &lt;+84&gt;:	jne    0x5555555552cc &lt;save_ciphertext_info+93&gt;
</span><span style="color:#323232;">   0x00005555555552c5 &lt;+86&gt;:	mov    eax,0xffffffff
</span><span style="color:#323232;">   0x00005555555552ca &lt;+91&gt;:	jmp    0x5555555552fa &lt;save_ciphertext_info+139&gt;
</span><span style="color:#323232;">   0x00005555555552cc &lt;+93&gt;:	mov    rdx,QWORD PTR [rbp-0x28]
</span><span style="color:#323232;">   0x00005555555552d0 &lt;+97&gt;:	lea    rax,[rbp-0x20]
</span><span style="color:#323232;">   0x00005555555552d4 &lt;+101&gt;:	mov    rcx,rdx
</span><span style="color:#323232;">   0x00005555555552d7 &lt;+104&gt;:	mov    edx,0x1
</span><span style="color:#323232;">   0x00005555555552dc &lt;+109&gt;:	mov    esi,0x18
</span><span style="color:#323232;">   0x00005555555552e1 &lt;+114&gt;:	mov    rdi,rax
</span><span style="color:#323232;">   0x00005555555552e4 &lt;+117&gt;:	call   0x5555555550a0 &lt;fwrite@plt&gt;
</span><span style="color:#323232;">   0x00005555555552e9 &lt;+122&gt;:	mov    rax,QWORD PTR [rbp-0x28]
</span><span style="color:#323232;">   0x00005555555552ed &lt;+126&gt;:	mov    rdi,rax
</span><span style="color:#323232;">   0x00005555555552f0 &lt;+129&gt;:	call   0x555555555030 &lt;fclose@plt&gt;
</span><span style="color:#323232;">   0x00005555555552f5 &lt;+134&gt;:	mov    eax,0x0
</span><span style="color:#323232;">   0x00005555555552fa &lt;+139&gt;:	mov    rcx,QWORD PTR [rbp-0x8]
</span><span style="color:#323232;">   0x00005555555552fe &lt;+143&gt;:	xor    rcx,QWORD PTR fs:0x28
</span><span style="color:#323232;">   0x0000555555555307 &lt;+152&gt;:	je     0x55555555530e &lt;save_ciphertext_info+159&gt;
</span><span style="color:#323232;">   0x0000555555555309 &lt;+154&gt;:	call   0x555555555040 &lt;__stack_chk_fail@plt&gt;
</span><span style="color:#323232;">   0x000055555555530e &lt;+159&gt;:	leave
</span><span style="color:#323232;">   0x000055555555530f &lt;+160&gt;:	ret
</span><span style="color:#323232;">End of assembler dump.
</span><span style="color:#323232;">(gdb) b *save_ciphertext_info+117
</span><span style="color:#323232;">Breakpoint 2 at 0x5555555552e4: file vuln.c, line 46.
</span><span style="color:#323232;">(gdb) c
</span><span style="color:#323232;">Continuing.
</span><span style="color:#323232;">hunter2
</span><span style="color:#323232;">s4lt
</span><span style="color:#323232;">
</span><span style="color:#323232;">Breakpoint 2, ...
</span><span style="color:#323232;">46	    fwrite(&amp;blob, sizeof(blob), 1, save_file);
</span><span style="color:#323232;">(gdb) p &amp;blob-&gt;scheme
</span><span style="color:#323232;">$2 = (unsigned char *) 0x7fffffffe0d0 &quot;\002unter2\n&quot;
</span></pre>
</code></pre>
<p>Here, gdb misinterpets the <code>unsigned char</code> datatype of <code>scheme</code> as a character array then dumps the “string”. By looking at the address of each field we see both <code>&amp;creds-&gt;key</code> and <code>&amp;blob-&gt;scheme</code> are allocated at <code>0x7fffffffe0d0</code>.</p>
<p>While this example is contrived, it is important to consider. To mitigate this behaviour there are several approaches.</p>
<ul>
<li>Memset the entire struct before assigning values.</li>
</ul>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> encrypted blob;
</span><span style="color:#323232;">memset(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">blob, </span><span style="color:#183691;">&#39;</span><span style="color:#0086b3;">\0</span><span style="color:#183691;">&#39;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">sizeof</span><span style="color:#323232;">(blob));
</span><span style="color:#323232;">
</span><span style="color:#323232;">blob.scheme </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> BLOWFISH;
</span><span style="color:#323232;">blob.uid </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> uid</span><span style="font-weight:bold;color:#a71d5d;">++</span><span style="color:#323232;">;
</span><span style="color:#323232;">blob.version </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span></pre>
</code></pre>
<ul>
<li>Write each field separately as mentioned previously.</li>
</ul>
<pre style="background-color:#ffffff;">
<span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> encrypted blob </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">{.scheme </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> BLOWFISH, uid </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> uid</span><span style="font-weight:bold;color:#a71d5d;">++</span><span style="color:#323232;">, .version </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">};
</span><span style="color:#323232;">
</span><span style="font-style:italic;color:#969896;">/* snip */
</span><span style="color:#323232;">fwrite(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">blob-&gt;scheme, </span><span style="font-weight:bold;color:#a71d5d;">sizeof</span><span style="color:#323232;">(blob.scheme), save_file);
</span><span style="color:#323232;">fwrite(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">blob-&gt;uid, </span><span style="font-weight:bold;color:#a71d5d;">sizeof</span><span style="color:#323232;">(blob.uid), save_file);
</span><span style="color:#323232;">fwrite(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">blob-&gt;version, </span><span style="font-weight:bold;color:#a71d5d;">sizeof</span><span style="color:#323232;">(blob.version), save_file);
</span></pre>
</code></pre>
</article>
</body>
<footer>updated: 2022-08-04</footer>
</html>

